#! /usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2013 Canonical Ltd.
# Author: St√©phane Graber <stgraber@ubuntu.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Fetches the list of pending rebuilds."""

from optparse import OptionParser
import os
import subprocess
import sys

sys.path.insert(0, os.path.join(sys.path[0], os.pardir, "lib"))
from cdimage.config import Config
from cdimage.tree import Publisher, Tree


def main():
    parser = OptionParser(usage="Usage: %prog [options] SERIES INSTANCE")
    parser.add_option('-b', '--build', help="Build any pending product",
                      action="store_true", default=False)
    _, args = parser.parse_args()

    if len(args) < 2:
        parser.error("need series and instance")

    config = Config()
    tree = Tree.get_daily(config)
    publisher = Publisher.get_daily(tree, "daily")

    # Only import it here to avoid --help failing from the bzr branch
    from isotracker import ISOTracker

    tracker = ISOTracker(target="%s-%s" % (args[1], args[0]))

    if not _.build:
        # List all the pending entries
        for rebuild in tracker.qatracker.get_rebuilds("Requested"):
            print(" - %s for %s (requested by %s) => %s " %
                  (rebuild.product_title, rebuild.series_title,
                   rebuild.requestedby_name,
                   publisher.cdimage_project(rebuild.product_title, args[1])))
        return

    count = 1
    while 1:
        rebuilds = {}
        queue = tracker.qatracker.get_rebuilds("Requested")

        if not queue:
            break

        for rebuild in queue:
            project = publisher.cdimage_project(rebuild.product_title, args[1])

            project_id = "%s/%s" % (project[0], project[1])

            if project_id not in rebuilds:
                rebuilds[project_id] = []

            rebuilds[project_id].append([rebuild] + list(project))

        print("Rebuild batch %s" % count)
        project_id = rebuilds.keys()[0]
        entries = rebuilds[project_id]
        project, build_type = project_id.split("/")
        arches = " ".join([entry[4] for entry in entries])

        for entry in entries:
            entry[0].status = 1
            entry[0].save()
            print(" - %s for %s (requested by %s) => %s " %
                  (entry[0].product_title, entry[0].series_title,
                   entry[0].requestedby_name, entry[1:]))

        env = dict(os.environ)
        env['ARCHES'] = arches
        env['DIST'] = entries[0][0].series_title.lower()
        cmd = ["for-project", entry[1], "cron.%s" % entry[2]]

        if build_type not in ("daily"):
            cmd += ["--live"]

#        print("ARCHES=%s DIST=%s %s" %
#              (env['ARCHES'], env['DIST'], " ".join(cmd)))

        process = subprocess.Popen(cmd, env=env)
        print(process.wait())

        count += 1


if __name__ == "__main__":
    main()
